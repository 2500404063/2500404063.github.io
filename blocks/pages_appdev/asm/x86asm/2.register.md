# 寄存器
寄存器也是一种储存器，但是为什么要单独拿出来呢？
因为寄存器不属于内存的一部分，而是属于CPU内部的一部分，类似RAM。
所以操作寄存器比操作内存要快，因为导线距离短。

## 通用寄存器
对于x86 CPU的寄存器，有8个通用寄存器，但是有使用的潜规则
1. EAX：通常用来执行加法，函数调用的返回值一般也放在这里面
2. EBX：数据存取
3. ECX：通常用来作为计数器，比如for循环
4. EDX：读写I/O端口时，edx用来存放端口号
5. ESP：栈顶指针，指向栈的顶部
6. EBP：栈底指针，指向栈的底部，通常用ebp+偏移量的形式来定位函数存放在栈中的局部变量
7. ESI：字符串操作时，用于存放数据源的地址
8. EDI：字符串操作时，用于存放目的地址的，和esi两个经常搭配一起使用，执行字符串的复制等操作

对于一些其他名称的解释：
AL：16位寄存器的低8位
AH：16位寄存器的高8位
AX：16位寄存器
EAX：32位寄存器
RAX：64位寄存器

> 除了扩展原来存在的通用寄存器，x64架构还引入了8个新的通用寄存器：
> r8-r15

在32位时代，函数调用的参数大部分还是靠栈来传递，也有用寄存器来传递的，如C++ this指针使用ecx寄存器传递，不过能用的寄存器毕竟不多。
64位时代，参数的传递大部分用寄存器来传递了，速度更快。

## 标志寄存器
标志寄存器，里面有众多标记位，记录了CPU执行指令过程中的一系列状态，这些标志大都由CPU自动设置和修改：
CF 进位标志
PF 奇偶标志
ZF 零标志
SF 符号标志
OF 补码溢出标志
TF 跟踪标志
IF 中断标志

## 指令寄存器
EIP: 指令寄存器可以说是CPU中最最重要的寄存器了，它指向了**下一条**要执行的指令所存放的地址。
同样的，在x64架构下，32位的eip升级为64位的rip寄存器。

## 段寄存器
段寄存器产生的原因是因为8086CPU的地址总线只有16条，
所以采用了段地址(基址)+偏移地址=物理地址的方式来寻址。

CPU来管理内存的一个非常重要的方式是，分段内存管理。
> 当CPU处于16位实地址模式下时，段寄存器存储段的基地址，寻址时，将段寄存器内容左移4位（乘以16）得到段基地址+段内偏移得到最终的地址。

> 当CPU工作于保护模式下，段寄存器存储的内容不再是段基址了，此时的段寄存器中存放的是段选择子，用来指示当前这个段寄存器“指向”的是哪个分段。注意我这里的指向打了引号，段寄存器中存储的并不是内存段的直接地址，而是段选择子，它的结构如下：


段寄存器有以下几种，1-4是16位CPU时就有的段寄存器，5-6是32位新增的。
1. CS：Code段地址
2. DS：Data段地址
3. SS：Stack段地址
4. ES：Extra段地址
5. FS：Data段地址（32位新增）
6. GS：Data段地址（32位新增）

## 控制寄存器
32位CPU总共有cr0-cr4共5个控制寄存器，64位增加了cr8。他们各自有不同的功能，但都存储了CPU工作时的重要信息：

cr0: 存储了CPU控制标记和工作状态
cr1: 保留未使用
cr2: 页错误出现时保存导致出错的地址
cr3: 存储了当前进程的虚拟地址空间的重要信息——页目录地址
cr4: 也存储了CPU工作相关以及当前人任务的一些信息
cr8: 64位新增扩展使用

cr0：
一些重要的标记位含义如下：
PG: 是否启用内存分页
AM: 是否启用内存对齐自动检查
WP: 是否开启内存写保护，若开启，对只读页面尝试写入时将触发异常，这一机制常常被用来实现写时复制功能
PE: 是否开启保护模式
除了CR0，另一个值得关注的寄存器是CR3，它保存了当前进程所使用的虚拟地址空间的页目录地址，可以说是整个虚拟地址翻译中的顶级指挥棒，在进程空间切换的时候，CR3也将同步切换。
具体可以参考intel的x86 x64CPU手册。

## 调试寄存器
### 软件断点
在x86/x64CPU内部，还有一组用于支持软件调试的寄存器。
程序能够被调试，关键在于能够被中断执行和恢复执行，被中断的地方就是我们设置的断点。那程序是如何能在遇到断点的时候停下来呢？

对于一些解释执行（PHP、Python、JavaScript）或虚拟机执行（Java）的高级语言，这很容易办到，因为它们的执行都在解释器/虚拟机的掌控之中。

而对于像C、C++这样的“底层”编程语言，程序代码是直接编译成CPU的机器指令来执行的，这就需要CPU来提供对于调试的支持了。

对于通常的断点，也就是程序执行到某个位置下就停下来，这种断点实现的方式，在x86/x64上，是利用了一条软中断指令：int3（注意不是int 3，两者虽然功能相同，但是本质原理不一样，见后面的syscall)来进行实现的。

### 硬件断点
在x86架构CPU内部，提供了8个调试寄存器DR0~DR7。

DR0~DR3：这是四个用于存储地址的寄存器

DR4~DR5：这两个有点特殊，受前面提到的CR4寄存器中的标志位DE位控制，如果CR4的DE位是1，则DR4、DR5是不可访问的，访问将触发异常。如果CR4的DE位是0，则DR4和DR5将会变成DR6和DR7的别名，相当于做了一个软链接。这样做是为了将DR4、DR5保留，以便将来扩展调试功能时使用。

DR6：这个寄存器中存储了硬件断点触发后的一些状态信息

DR7：调试控制寄存器，这里面记录了对DR0-DR3这四个寄存器中存储地址的中断方式（是对地址的读，还是写，还是执行）、数据长度（1/2/4个字节）以及作用范围等信息

通过调试器的接口设置硬件断点后，CPU在执行代码的过程中，如果满足条件，将自动中断下来。

如果想要找出是谁偷偷修改了全局变量的值，只需要通过调试器设置一个硬件写入断点即可。

## 描述符寄存器
在x86/x64系列CPU中，有三个非常重要的描述符寄存器，它们分别存储了三个地址，指向了三个非常重要的描述符表。
描述表就是一个数据结构，储存了一些信息，描述寄存器指向这些表。
表有三个非常重要的描述表：
1. GDT：全局描述表（Global Description Table）
2. LDT：局部描述表（Local Description Table）
3. IDT：中断描述表（Interrupt Description Table）

这些表被三个寄存器指向：
1. GDTR：指向全局描述表（Global Description Table Register）
2. LDTR：指向局部描述表（Local Description Table Register）
3. IDTR：指向中断描述表（Interrupt Description Table Register）

### GDT和LDT
GDT是全局唯一的，只能有一个。
LDT是可以有多个的，随着任务段的切换而切换。
GDT和LDT表都描述了内存分段情况，包含了：
段地址，段大小，段权限，段类型等信息

### IDT
这个表记录了CPU中断函数的地址。
即，当CPU发生了XXX中断，XXX异常的时候，应该去跳转到哪个地址(函数)去执行。
和单片机的中断向量表类似。

IDT中的表项称为Gate，中文意思为门，因为这是应用程序进入内核的主要入口。虽然表的名字叫中断描述符表，但表中存储的不全是中断描述符，IDT中的表项存在三种类型，对应三种类型的门：

1. 中断门：就是中断函数
2. 任务门：见下面的任务寄存器
3. 陷阱门：如int3

## 任务寄存器
现代操作系统，都是支持多任务并发运行的，x86架构CPU为了顺应时代潮流，在硬件层面上提供了专门的机制用来支持多任务的切换，这体现在两个方面：

CPU内部设置了一个专用的寄存器——任务寄存器TR，它指向当前运行的任务。

然后又定义了描述任务的数据结构TSS，里面存储了一个任务的上下文（一系列寄存器的值）
如:
1. EAX=xx
2. EBX=xx
3. ...

x86CPU的构想是每一个任务对应一个TSS，然后由TR寄存器指向当前的任务，执行任务切换时，修改TR寄存器的指向即可，这是硬件层面的多任务切换机制。这样就实现了修改指向，从而修改各种寄存器的值和栈的地址。

这个构想其实还是很不错的，然而现实却打了脸，包括Linux和Windows在内的主流操作系统都没有使用这个机制来进行线程切换，而是自己使用软件来实现多线程切换。

虽然操作系统不依靠TSS来实现多任务切换，但这并不意味着CPU提供的TSS操作系统一点也没有使用。还是存在一些特殊情况，如一些异常处理会使用到TSS来执行处理。

## 模型特定寄存器组MSR
注意，这是一组寄存器，统称为MSR，是有多个寄存器的。
这个寄存器组的目的是为了支持CPU的一些功能。

例如
1. IA32_SYSENTER_CS
2. IA32_SYSENTER_ESP
3. IA32_SYSENTER_EIP

这三个MSR寄存器是用来实现**快速系统调用(fast syscall)**。

在早期的x86架构CPU上，系统调用依赖于软中断实现，类似于前面调试用到的int 3指令，在Windows上，系统调用用到的是int 2e，在Linux上，用的是int 80。

**软中断毕竟还是比较慢的，因为执行软中断就需要内存查表，通过IDTR定位到IDT，再取出函数进行执行。**

系统调用是一个频繁触发的动作，如此这般势必对性能有所影响。
在进入奔腾时代后，就加上了上面的三个MSR寄存器，分别存储了执行系统调用后，内核系统调用入口函数所需要的段寄存器、堆栈栈顶、函数地址，不再需要内存查表。
快速系统调用还提供了专门的CPU指令sysenter/sysexit用来发起系统调用和退出系统调用。

在64位上，这一对指令升级为syscall/sysret。

## 总结
但这并不是x86CPU全部所有的寄存器，除了这些，还存在XMM、MMX、FPU浮点数运算等其他寄存器，这些寄存器是为了让浮点运算更加快速。

可见，通用CPU的构造其实是非常复杂的，如果想更加深入具体地了解需要去查Intel 86/64的CPU芯片手册。
MCS-51，RISC-V，Arm的CPU是比较容易一点的，所以如果想要制作芯片，可以先从模仿这些开始。
也可以自己设计自己的CPU指令集和CPU架构，但是这样会导致没有现有操作系统和编译器的支持，所以也需要自己写操作系统和编译器。
至于通用CPU嘛……时间太久