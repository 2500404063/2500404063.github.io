# 网络层
在网络层定义了很多的底层协议。
网络层决定数据在网络中的**传输路径**，**数据路由**（决定数据在网络的路径）
本节我们要讲述：
1. IP(Internet Protocol)网际协议
2. ARP(Address Resolution Protocol)地址解析协议
3. ICMP网际控制报文协议
4. 子网划分
5. IP多播
6. IGMP网际管理协议
7. 虚拟专用网VPN
8. NAT地址转换

![network_layer](./pages_appdev/network/res/network_layer.png)

## IP协议
我们平时接触最多的是IP，就是类似于192.168.1.1这种东西。
IP地址的格式：255.255.255.255  四个字节。
IP地址被划分成不同的类型，以用于不同的功能。
![ipaddress](./pages_appdev/network/res/ipaddress.png)
从图中可见，IP地址被划分成两级：[网络号，主机号]，现在已经不用了。
新的分级是三级：[网络号，子网号，主机号]，在后文的子网当中讲到。

各类IP地址的范围：
```text
A类：0.0.0.0 - 127.255.255.255
B类：128.0.0.0 - 191.255.255.255
C类：192.0.0.0 - 223.255.255.255
D类：224.0.0.0 - 239.255.255.255
E类：240.0.0.0 - 247.255.255.255
```
IP地址具有私有IP和公有IP地址的区分。
公有IP地址是全球唯一的，而私有IP地址对于不同的局域网是可以重复的。
所以在各类的IP地址中，都保留了一些私有的IP地址。
```text
A类地址：10.0.0.0～10.255.255.255      （大规模IP，小区）
B类地址：172.16.0.0～172.31.255.255    （中规模IP，厂房）
C类地址：192.168.0.0～192.168.255.255  （小规模IP，家庭）
```

对于这些IP地址，有一些规范：
主机号为0，是保留地址，表示该**网络地址**。
主机号为1，表示的是网关（gateway）的地址。

**IP是无连接协议，知道IP地址后，就可以给目标IP发送数据。**

### IP数据报的格式
![ip_packet](./pages_appdev/network/res/ip_packet.png)
从图中可见IP数据报的头结构包含了许多的信息，其中最重要的是**源地址**和**目的地址**，标识了这个数据包的来源和去向。
**版本：**表明IP地址的类型，IPv4还是IPv6
**首部长度：**表示IP头的长度，因为IP头是可变长度，所以用这个来指示IP数据帧的头部的长度。
**区分服务：**一般不用
**总长度：**IP头和数据的总长度
这里还有一个概念，MTU（Maximum Transfer Unit）最大传输单元。
这个标识了链路层所支持的最大一次传输长度（即一个帧的最大总长度），一般是1500，单位是字节。

**标识：**当数据包的总长度大于MTU的时候，就必须要对数据进行分片。该字段表示数据包的ID，占16位。
例如，当一个包被分成两个帧的时候，这两个包具有相同的**标识**，当两个包没有被分片的时候，具有不同的标识。

**标志(flag)：**占3位，但是只有2位有意义。
0位：MF(More Fragment)，为1表示后面还有分片，为0表示当前包已经是分片的最后一个包了。
1位：DF(Don't Fragment)，为1表示该包不能分片，为0表示该包能分片。
2位：无意义

**片偏移：**表示当前分片的包，在整个数据包当中的位置。片偏移以8个字节为偏移单位，即为1时候，相当于在整个数据包中的第八个字节的位置。

**生存时间：**TTL(Time to Live)指明了该数据帧在网络中的生存时间。设置这个的目的是为了避免，有些数据包在网络中找不到位置，结果就一直在网络中弹来弹去。设置一个存活时间，当超过该时间，就直接丢弃该包。在老的IP协议当中，每隔一段时间会将这个值减小1，直到为0为止，现在表示每经过一个路由就减一，所以现在TTL的含义应该是**跳数限制**，因为历史原因，保留了原称呼。

**协议：**定义了该IP数据报的协议。这里需要知道的是，IP协议是一个比较底层的协议，在IP协议的基础之上，建立了很多其他的协议。
例如，协议名(值)：ICMP(1)，IGMP(2)，IP(4)，TCP(6)，EGP(8)，IGP(9)，UDP(17)，IPv6(41)，ESP(50)，OSPF(89)

**首部校验和：**用于检验IP头的正确性。具体的算法在后面会讲。

## ARP协议
在网络层，我们定位网络设备的方法是通过IP地址来定位。
但是实际上，传输信号要通过网卡这些硬件设备来传输，这些设备只认识MAC地址。
ARP协议的作用就是实现了IP地址转换成MAC地址。
还有一个协议叫做RARP，就是反ARP协议，实现MAC地址转IP地址，但是现在已经不用了。

如下图，表示了IP地址和MAC地址的关系。
![ip_mac](./pages_appdev/network/res/ip_mac.png)

## IP层的转发过程
IP层的转发的过程，叫做路由。
实现路由的办法是建立一个**路由表**。
路由表的格式：
```text
目的地址           下一跳地址
127.0.0.1         127.0.0.1
0.0.0.0          192.168.2.1
```

其中0.0.0.0表示默认路由，即当没有匹配的目的地址的时候，就使用这条路由表。
路由表是可以通过**系统的命令**来修改的。

路由是通过路由器（一种硬件）来实现的，路由器内部就有一个上述的**路由表**。
过程如下图所示：
![route](./pages_appdev/network/res/route.png)

## 子网划分
因为将IP地址划分成两级会有IP地址的利用率太低，灵活性也低，实际上的主机数量并没有那么多。
所以新的IP协议当中把IP地址划分成三级：[网络号，子网号，主机号]

子网的概念：将本来一群的主机，划分成多个子网。
如下图，对于二级网络，这些一群主机都是属于一个网络的。
![sub-net-1](./pages_appdev/network/res/sub-net-1.png)
如下图，对于三级网络，这些主机根据子网号，划分成了多个子网。
![sub-net-2](./pages_appdev/network/res/sub-net-2.png)

145.13.0.0表示是保留地址，表示**该网络**。
145.13.x1.x2，145.13是网络号，x1是子网号，x2是主机号

对于一个网络的外部的网络来说，是不知道当前网络具有多少个子网的。
数据发给路由器R1（145.13.0.0）然后这个路由器根据目标地址，转发到对应的子网（子网也是有路由器的），子网把数据包发给对应的主机。

### 子网掩码
从二级网络变成三级网络，就会产生一个问题，子网号应该占几位？主机号应该占几位？
子网掩码就是实现动态调整子网号和主机号的占比。
子网掩码的原理如下图。
通过将IP地址与子网掩码按位与一下，得到子网的网络地址。
![sub-net-mask](./pages_appdev/network/res/sub-net-mask.png)

举个不一样的例子：
IP地址：192.168.72.5
子网掩码：255.255.224.0
子网地址：192.168.64.0

### 子网的数据转发过程
因为有了子网，所以路由表也会发生变化。
```text
目的地址          子网掩码             下一跳地址
127.0.0.1     255.255.255.0           127.0.0.1
0.0.0.0       255.255.255.0             端口1
```

过程如下：
1. 将**IP报中**的目的地址取出，和路由表中的所有的子网掩码进行按位与，记结果为D
2. D和**路由表当中**的目标地址比较，匹配就跳到下一级。若失败，到第三步。
3. **IP报中的目的的地址**直接和**路由表当中的目的地址**比较，匹配就跳到下一级。若失败，到第四步。
4. 如果有默认路由，则跳到默认路由的下一级。若失败则报错。

如图所示：
![sub-net-transfer](./pages_appdev/network/res/sub-net-transfer.png)

## ICMP
ICMP是用来传输异常报告的协议。PING命令就是通过ICMP协议实现的。
ICMP协议的头定义：
![icmp_header](./pages_appdev/network/res/icmp_header.png)
常用的ICMP报文类型：
```text
报文类型     值       含义

差错报告     3        终点不可到达
差错报告     11       时间超过
差错报告     12       参数问题
差错报告     12       改变路由（Redirect)

询问报文     8/0      回显请求
询问报文     13/14    时间戳请求
```

## IP多播
之前讲的都是单播，即点对点通信。
多播实现的功能就是，只发送一次数据，就可以发送给多台机器。
多播分为**局域网内的硬件多播**，和**互联网多播**。
因为多播本来就只能在局域网内进行。
互联网多播其实还是通过局域网多播实现的（先通过单播给多个局域网，这些局域网负责多播）

### 局域网多播
IP多播使用的是D类IP地址，为什么呢？
以太网硬件的MAC地址的第一个字节的最低位，为1，表示多播地址。
00-00-5E-00-00-00到00-00-5E-FF-FF-FF，所以最多有23位可以用于多播的地址。
而D类IP地址的范围是28位，所以其中一部分不能用于多播地址，最高位的5位没有用，所以会出现多个D类地址其实是同一个多播的MAC地址的情况。
![multransfer](./pages_appdev/network/res/multransfer.png)

### IGMP和多播路由选择协议
局域网多播需要用到两个协议：IGMP，多播路由选择协议
IGMP叫做网际组管理协议，起到的作用就是，使得多播路由器知道多播成员的信息。
IGMP管理了多播成员的进入，退出等，重新建立起多播的路由。
![igmp](./pages_appdev/network/res/igmp.png)
上图强调了IGMP的使用范围是**局域网范围之内**。


只有IGMP还不能实现多播，还需要**多播路由选择协议**。
![mulroute](./pages_appdev/network/res/mulroute.png)
多播的数据报，可以由多播组内的成员发出，也可以由多播组外的成员向多播地址发送数据报。
所以多播的路由不能只考虑目的地址，也要考虑数据报的来源。
多播路由选择协议，解决了上面的问题。具体的内容这里不做解释了。

## 虚拟专用网VPN
上一节我们讲过各类IP地址被分为私有地址和共有地址。
其中私有地址是**不能直接**和互联网（共有地址）进行通信的，只能私有地址内部的局域网进行通信。
这样的局域网也叫`本地网`，也叫`专用网`。

所谓虚拟专用网，顾名思义，就是虚假的专用网，将两个本地网的机器，形成一个专用网。
并且，这期间的数据还可以经过加密，所以也可用来**实现加密通信**。
只有连接上VPN，才能访问虚拟局域网内的资源，所以也可以**实现访客管理**。

![vpn](./pages_appdev/network/res/vpn.png)
如上图，主机X要给主机Y发送信息。
1. 主机X发出的包的，源地址是10.1.0.1，目的地址是10.2.0.3
2. 这个数据报，经过路由器R1，发现这个包必须要通过互联网才能到达。
3. 所以路由器R1将整个包（包括IP头）加密，当作数据，再包上一层新的IP头，源地址是125.1.2.3，目的地址是194.4.5.6
4. 于是这个包就经过互联网到达R2
5. R2将这个包解密，发现是发给10.2.0.3的，于是将数据转发给10.2.0.3
6. Y发给X也是类似。

由此，实现了X主机和Y主机看对方都是本地IP地址，所以形成了一个虚拟的专用网。

这里要提一下第二步，路由器R1是如何发现这个包需要通过互联网才能到达呢？
没错，就是路由表。
```text
目的网络地址	    子网掩码    	    下一跳地址	          接口
10.153.64.1	       255.255.255.255	   10.153.80.253	    WAN
169.254.142.0	   255.255.255.0	   169.254.142.99	    WAN
192.168.1.0	       255.255.255.0	   192.168.1.1	        LAN/WLAN
0.0.0.0	           0.0.0.0	           10.153.64.1	        WAN
```
从上面的路由表看出，当我想要访问192.168.100.1的时候，会跳到10.153.64.1（也就是WAN口，就是奔着互联网去的）

## 网络地址转换NAT
因为IP地址不足，所以产生了本地网，所以没办法每一台电脑都拥有一个IP地址。
因为本地网没办法直接和互联网进行通信，但是又需要实现本地网能够访问互联网，应该怎么办呢？
所以就产生了NAT技术。
注意的是，普通的NAT是路由器实现的，而不需要软件实现。

下面来讲讲NAT的原理。
**讲之前，我们需要明确一点：**虽然我们的家用电脑大部分都是私有IP，但是我们的最顶部一定是有一个公有IP的，否则就没办法访问互联网了。

![nat](./pages_appdev/network/res/nat.png)
主机A，想要给互联网上的主机B发送消息。
1. 主机A产生一个数据报，源地址是192.168.0.3，目的地址是213.18.2.4
2. 这个数据报到达NAT路由器，而NAT路由器负责把192.168.0.3转换成172.38.1.5
3. 因为172.38.1.5和213.18.2.4都是公有IP，是可以相互通信的
4. 当NAT路由器收到主机B返回的数据报，其源地址是213.18.2.4，目的地址是172.38.1.5
5. NAT路由器再把目的地址172.38.1.5，转换成192.168.0.3
6. 然后主机A就收到了主机B的信息

上面的这个地址转换过程形成了一张NAT地址转换表：
![nat_table](./pages_appdev/network/res/nat_table.png)

上面就是完整的NAT转换过程。
网络通信不仅仅只有IP地址，还有端口号。
端口号是属于`运输层`的东西，将在下一节当中讲述。
所以，也可以实现IP地址和端口号的NAT转换——NAPT（Network Address And Port Translation）
原理相近，NAPT的转换表如图：
![napt_table](./pages_appdev/network/res/napt_table.png)