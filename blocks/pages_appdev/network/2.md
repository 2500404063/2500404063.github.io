# 运输层
运输层主要是偏向软件。
本节我们将讲解：
1. 端口概念
2. UDP协议
3. TCP协议

## 运输层的作用
网络层是负责主机与主机之间的通信。
然而我们知道，实际上软件在网络通信的时候是进程是数据的接收者和发送者。
做过网络编程的知道，除了IP还有端口的概念。
运输层为进程间，提供端到端的通信。

网络层的IP协议只对头部进行校验，而没有对数据包进行校验。
所以运输层会对数据包进行校验。
（ICMP协议在网络层会对数据包进行校验，和IP头不同）

## UDP
UDP协议只在IP协议的基础上增加了一部分功能。
UDP协议具有以下特点：
1. 无连接的
2. 不可靠传输（尽最大努力传输）
3. 面向报文：即一次传输一个报文，也就是UDP协议不会自己分包和合并包，有多长就一次性发完。但是到了IP层依然会分包，所以不能太长，太长会影响IP层的效率，太短IP头太长，数据太少，也会影响传输效率。一次1024KB是不错的。
4. UDP没有拥堵控制：即发送的速率是恒定的，不会出现数据太多而阻塞，但是会有丢失的情况。
5. UDP支持一对一，一对多，多对一的通信
6. UDP头部小，只有8字节

### UDP头部
![udp_header](./pages_appdev/network/res/udp_header.png)
1. 源端口：选用，如果需要接收数据，就填写，否则填0
2. 目的端口：目的端口号
3. 长度：头部和数据的总大小
4. 校验和：校验和需要添加一个伪首部来计算。具体的这里不展开。

每个都占两个字节。

如果UDP传输有问题，那么发送端会收到一个ICMP报文，指示错误。

## TCP
TCP协议较为复杂，有如下特点：
1. 面向连接传输
2. 点对点通信
3. 可靠交付：无丢失，不重复，有顺序
4. 全双工通信：具有缓冲区，数据先到缓冲区
5. 字节流通信：不像UDP分成一个一个报文，而是无结构的字节流，也就是没有边界，会出现粘包问题。

### TCP的连接
TCP的连接是一种“虚假”的连接，并不是物理上的线路连接。
TCP连接的端口叫做套接字。IP和端口拼接起来，就是套接字，即IP:PORT
C语言当中的socket函数，返回的是一个套接字的描述符，与上述概念不同。

### TCP可靠传输原理
TCP的可靠传输是通过`应答`实现的。
例如A发给B，B收到后，B给A返回ACK表示收到了，A收到B的ACK后才会进行发送下一个包。
![tcp_ack](./pages_appdev/network/res/tcp_ack.png)
**必须要等待ACK才能发下一次，这种方式会导致传输通道利用率很低。**

于是就产生了下面的这种方式：
![ack2](./pages_appdev/network/res/tcp_ack2.png)
这个思想也很简单，就是不再是一应一答的方式。
而是一直发送，不管上一次有没有收到ACK。
当接收方收到后，ACK也会返回。
发送方根据收到的ACK情况来找到出错的位置，在哪出错就从出错的位置重新发送。

假设有5个包，发送方把五个包不等待地发送完了。
然后接收方返回了2个ACK，然后不能返回第三个ACK了。
这时候发送方知道，从第三个数据包开始没发送成功，然后就会从这里重新发送。

### TCP头部
![tcp_header](./pages_appdev/network/res/tcp_header.png)
1. 源端口，目标端口：和UDP一样
2. 序号：TCP当中的数据部分，每一个字节都占一个序号。例如一个TCP报文的序号是301，数据长度为100，则301是该数据第一个字节的序号，最后一个的序号是400，下一个报文的序号应该从401开始。填满后重0开始。
3. 确认号：表示发送方期望接收方下一个报文的，第一个字节数据的序号。例如，B收到A发的序号为501，长度为200的包，则表面B已经收到了序号为700为止的数据。则B返回给A的确认号应该是701，即表示A应该从第701序号开始发送数据。这里其实就是TCP安全传输的原理。
4. 数据偏移：指示数据段开始的位置相对于TCP头的开始位置偏移了多少。其实也就是TCP头部有多大。因为TCP头是可变长度。注意，数据偏移是以4字节作为单位，即偏移1，表示偏移4字节。
5. 保留：填写0
6. URG(紧急)：表示该报文是紧急数据，应该优先传送，而不需要按顺序传输。例如CTRL+C这个中断命令，应该打断正在发送的数据。
7. ACK(Acknowledge)：表示应答。在TCP建立连接后，所有的包都应该把ACK置1.
8. PSH(推送PUSH)：因为TCP有缓冲区，所以要等缓冲区满了才会提交给接收方的应用程序。PUSH置1后，不需要等待缓冲区满。
9. RST(复位)：表示出现了致命错误，表示要求释放连接。可以用来阻止非法报文和非法连接。
10. SYN(同步)：当SYN=1,ACK=0表示这是一个请求连接报文。若主机同意，主机返回SYN=1,ACK=1。
11. FIN(终止)：当FIN=1,表示数据都发完了，请求断开连接。
12. 窗口：使用窗口值，来告诉对方，当前还能接收多少字节的数据。例如，B给A发送，确认号是701，窗口是1000，表示，从701字节算起，B还能接收1000字节，让A发送数据的时候考虑这一点。窗口值是动态变化的。之所以有这个，是因为缓冲区是有大小限制的。如果缓冲区满了，但是应用程序还没有将缓冲区的数据拿出来，则后面的数据就接收不到了。
13. 校验和：和UDP类似，需要伪首部，但是还需要改一些值。
14. 紧急指针：仅当URG=1时有效，指示紧急数据有多大的长度。发完后，就恢复正常传输模式。有这个的原因是因为TCP的数据流是没有边界的，所以需要长度限制。

TCP流量控制：流量控制就是通过TCP头的`窗口`字段实现的。为了防止接收方来不及接收，
关于**建立连接**和**断开连接**，后面会更加详细介绍。

### TCP建立连接
TCP连接的建立需要进行三报文握手（三次握手翻译不好），如下图所示。
![tcp_connect](./pages_appdev/network/res/tcp_connect.png)
图中已经画得很明确了。
SYN=1的时候，不允许携带数据，但是要消耗一个序号。
seq：序号
ack：确认号

如果在第二次握手，分成两次：先ACK=1，再SYN=1，这样就变成四次握手，效果相同。

### TCP连接释放
TCP的服务器和客户都可以进行关闭连接，所以连接释放过程有一些复杂。
如下图表示客户主动关闭连接的过程。
当FIN=1表示请求断开连接，不允许携带数据，但是要消耗一个序号。
![tcp_close](./pages_appdev/network/res/tcp_close.png)

从上图可见，TCP的连接释放需要双方的同意。在半连接断开状态下，连接依然存在，客户端依然要接收服务器发来的数据，直到服务器也断开连接。

客户端会有一个TIME_WAIT的过程，需要等待一段时间才算真正关闭连接。
这个MSL(Max Segment lifetime)一般是2分钟，所以要等4分钟才能进入CLOSED状态。

目的之一，是为了客户端能够给服务端响应ACK，以确保服务端能够进入CLOSED状态。
ACK在传输的时候可能会丢失，如果服务端迟迟未收到ACK，则服务端会重新发送FIN=1，ACK=1。
TIME_WAIT阶段就是为了让服务端能够收到ACK，确保服务端的资源能够及时释放。
**主动断开方会出现TIME_WAIT，所以推荐客户端主动断开。**