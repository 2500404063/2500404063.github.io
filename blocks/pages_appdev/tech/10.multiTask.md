# 漫谈多任务

## 前言
哎，有好多事情要去做，计算机就是为了解决计算问题而诞生。
随着计算要求越来越高，计算机需要同时完成多件事情，怎么办呢？
今天我们来谈一谈计算机的多任务，来看看一些多任务的做法和思想。

## CPU多线程的设计
CPU在设计之初就有了`线程(Thread)`的概念。线程是CPU进行调度的最小单位。
CPU会在不同的线程里面进行执行命令。例如：
```json
线程1：{
    mov
    push
    mov
    mov
    pop
}
线程2：{
    mov
    push
    mov
    mov
    pop
}
```
那么CPU就会在这两个线程之间进行来回循环执行：
线程1：mov
线程2：mov
线程1：push
线程2：push
但是因为CPU的速度很快，所以感觉不到延迟。

每一个线程都具有自己独立的`栈空间`，共享`同一个进程的堆空间`。
所以在进行线程切换的时候，会有因为线程切换的时间开销。

启动一个线程就意味着要初始化一部分的空间（8MB)，这也需要花费一定的时间。
## CPU多核设计
随着技术发展，CPU出现了多核心。理解了多线程，多核心也很容易理解。
对于两个核心，CPU会同时执行两个线程的指令：
线程1:mov，线程2：mov
线程1：push，线程2：push

## 多线程模型：共享内存型多线程
代表语言：C++, Java
![thread_shared_memory](./pages_appdev/tech/res/thread_shared_memory.png)
对于这类共享内存多线程模型，应该说是最原始，也是最直接的方法。
因为同一个进程的堆内存是相同的，所以就可以轻而易举地实现线程间地通信。
优点就是方便，快速，直接。
缺点也显而易见，容易发生数据访问冲突，一个线程读取了另一个线程修改前的数据。
为此，这类的语言安排了`协程`，通过一些`锁`来保证资源每次只能被一个线程访问。

## 多线程模型：通信模型
代表语言：Golang，C#
![thread_message](./pages_appdev/tech/res/thread_message.png)
对于这类多线程模型，正是发现了共享内存多线程模型的缺点，所以创造了通信模型来解决那些缺点。
通过线程之间的通信而不是直接读取内存，实现了一种有序的数据读写方式，使得本来凌乱无序的多线程变得有序可控。

## 多任务：消息队列
一个任务的完成需要花费一定的时间，但是倘若任务太多如何保证所有的任务都能得以完成呢？
`队列`就是为了解决这个而产生。队列的思想在很多高并发场合都有使用。