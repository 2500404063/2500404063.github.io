# 多核编程
现在的CPU基本都是多核CPU，运行同一时间执行多条命令。
CPU执行的最小单位是线程。

一个线程拥有自己独立的栈。

## 线程的状态机
每一个线程拥有自己的栈。
但是堆大家都是共享的。
CPU的每一个核心都是并发的，他们的执行顺序是未知的。
当线程的数量大于CPU的核心数量的时候，空闲的CPU核心会切换到不同的线程，切换也需要花费时间。

## C语言的线程库
参考pthread.h

## 多核问题：原子性
原子性指一个操作是不可中断的，要么全部执行成功要么全部执行失败，且在多线程里面是独占的。
**原子操作：确保所有的操作都是具有原子性的**
lock :它把一个变量标识为一个线程独占的状态
unlock:它释放一个处理线程独占状态的变量，使释放后的变量能被其它线程锁定
read:它把一个变量的值从主内存中传输到线程的工作内存中，以便后面的load使用
load:将read命令传输的变量值放入工作内存中的变量副本
use:它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作
assign:它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作
store:它把工作内存中一个变量的值传送给主内存中以便随后的write操作使用
write:它把store操作从工作内存中得到的变量的值放入主内存的变量中

**在实现操作系统的时候，我们需要实现原子性，保证多核处理器的正确性。**

## 多核问题：顺序性
多核，给我们带来的还有另外一个问题——顺序性丢失。顺序性是针对编译器而言的。
编译器在优化我们的程序的时候，是按照顺序执行的方式去优化。
```java
public class Task {
	 static Object val =null;
	 static boolean finish =false;
	 public static void main(String[] args)
	 {
		 Runnable task1 = new Runnable() {
			 @Override
			 public void run() {
				 if(finish)
				 {
					 System.out.println(val.toString());
				 }
			 }
		 };
		 Runnable task2 = new Runnable() {
			 @Override
			 public void run() {
				 val = new Object();
				 finish =true;
			 }
		 };
	 }
}
```
然而因为编译器都是按照顺序执行的方式来优化代码的，所以会被优化成如下：
```java
@Override
public void run() {
     finish =true;
     val = new Object();
}
```
这个告诉我们，通过内存共享的方式来实现协程，是不正确的，会因为编译器的优化而出错。
但是我们可以在C语言当中，使用volatile关键字，可以避免编译器对变量读取的优化，
使得每次都是重新读取，而不是使用寄存器中缓存的值。

## 多核问题：即时可见性
是不是只要解决了原子性和顺序性就好了呢？
然而并不是，还有一个问题是来自于**现代CPU**的问题。
现代CPU为了尽可能地提高速度，CPU内部有多级流水线，CPU可以把汇编指令分成更小的指令，
然后同时执行这些更小的指令，CPU内部维护了一个有向无环图。
这相当于CPU在进行边“编译”边执行。
**会导致某些情况下CPU实际执行的汇编代码，不是我们写的汇编代码的顺序。**

有一句话非常好：计算机体系结构的木桶效应
意思是，计算机发展的过程中，哪里不足补哪里。
内存慢了，出现了内存的缓存
读取指令慢了，出现了CPU的流水线，上一条命令执行的时候，下一条命令就读取好了。
写地址慢了，就分析，在不影响结果的情况下，执行同时写入。
这就是intel和arm的架构如此之快的原因。

根据上面的CPU设计，假设如下的汇编代码
```asm
N1  mov $x, 1
N2  mov eax, $x
```
N1被1号CPU（线程）读取，
N2被2号CPU（线程）读取，
在不同的线程里面，现在的CPU每一个线程都有自己的一个缓冲区，对于共享的那部分内存来说，并不是立刻写入数据的。而是当延迟了任意时常后了之后才写入共享内存。
然而此时，当第二个线程去读取x的时候，x的值并没有发生改变，所以会得到非正确的值。

这就叫做**宽松内存模型**。inte为了让程序员可以更加方便，这成为了inte的CPU的历史包袱。
目前来说，这已经是可以买到的最强的intel的CPU了。

对于RISC-V和ARM这两种CPU架构，他们的内存模型是一种类似于分布式的模型，他们每一个线程都有自己的一份内存副本，这些副本之间可以任意同步，相当于是**没有共享内存的这一概念**。
所以某些情况下这些架构下的CPU比intel的CPU还要快。

**如何解决及时可见性的问题呢？**
1. 通过memory fence：C语言当中 __sync_synchronize();
2. 使用原子操作，对于某些操作使用lock前缀，或者在lock块内执行。

保证一段代码是线程独占，而不会被其他线程执行。

## 解决并发问题的正确办法
不是共享内存等一大堆的限制条件。
而是使用适当的机制（如队列，线程池等），将任务划分成多个可并行小任务，对于部分代码进行加锁，由此在保证程序正确性的前提下，发挥多核CPU的最佳性能。