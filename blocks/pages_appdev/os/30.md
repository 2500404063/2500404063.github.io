# RTOS设计（一）
从本篇文章，让我们一起来走进RTOS(Real-time Operation System)，我们将分析操作系统的功能，分析一些常见的设计方案。

## 思考RTOS
实时性：实时操作系统的实时性体现在，实时处理任务，一有任务，就立刻得到及时的处理。
多任务的要求：
1. 任务有状态：睡眠中，等待中，执行中，执行结束
2. 任务间要协程：任务间有执行顺序
3. 任务有优先级：紧急的先执行
4. 任务栈空间：因为RAM稀缺，所以不能固定Stack，应该可调。

## 调度算法
### 先来先服务FCFS
FCFS(First Come First Serve)，字面意思，哪个任务先发起，就先执行哪个任务，等这个服务完再服务下一个（Um，听起来有点怪怪的）。
这是一种最简单的调度算法，常用来做对实时性要求不高的任务调度，就像食堂打菜一样。
这种结构就是个**先进先出队列**，也就是FIFO。这个调度器是在任务执行完成后执行的。

### 时间片轮转法RR
RR(Round Robin)，在该算法当中，把一个较小的时间作为一个时间单位，比如10ms，通常是感受不到的时间。
每一个任务都有自己的时间片，调度器在任务队列里面来回转，执行时间超过当前任务的时间就切换到下一个任务。
这种结构就是个**环形队列**。这个调度器是在系统时钟内执行的。
RR算法是一种抢占式模型，一个任务还没执行完，CPU控制权就被其他任务夺走了。

### 优先级抢占模型
该模型遵循的原则是，每个任务有优先级，优先级高的先执行。
调度器所做的事情就是遍历每一个任务，根据他们的状态和优先级选择执行。

这个调度器的结构就是个**普通队列**。
这个调度器可以在任何地方人为执行，也可以在中断函数内执行。
手动调度：显式调用调度器，根据当前任务的状态进行调度。
自动调度：在硬件中断函数里面执行，当有硬件中断的时候执行调度器，进行调度。

## 协程算法
对于多任务来说，协程是必不可少的，协程的算法也有许多，有些很好使，有些会有一些问题。
### Flag协程
这种协程方式在某些情况下是错误的，但是也要提及一下。
这种方式就是定义一个变量，根据变量的值和if判断来实现多个任务之间的配合。

对于多核CPU来说，可以实现同时执行多条指令，那么变量的值可能会被同时更改，或者读取不及时，就会出现错误了。
但是对于单核CPU来说，这种方式是可行的，不过因为变量太多会导致凌乱，会有更好的方式。

### 互斥量：阻塞与唤醒
上面的那种软件方式对于多核来说有问题，该如何解决呢？
可以把那种Flag变量**放在系统内核层面**，因为调度器是单核单线程运行的，所以就可以保证调度器本身不会出现**写前读**的问题，然后就产生了阻塞与唤醒机制。
阻塞：就是把当前任务的状态改为休眠状态，把CPU控制权让出去。
唤醒：唤醒一个，或者唤醒一群任务。

### 互斥锁
互斥锁是互斥量的抽象封装，把上述的阻塞和唤醒进行了简化，变成：
SyncLock();     //如果上锁了就阻塞自身
Codes here...
SyncUnlock();   //唤醒所有

### Future/Promise
这种机制来自于现代编程语言JavaScript，CSharp，Dart……
至于是谁先设计的……这个就不追究了。
这是一种比较高层次的抽象协程方法，本质上还是`多任务`，`互斥量`，`阻塞与唤醒`实现的。
Await：等待一个任务执行完成，并阻塞当前任务。
Continue：创建一个任务，在一个任务执行完成后执行。

## 设计我们的RTOS
如果设计一个用户操作系统，成本太高，而且难以做到很高质量，所以不实用。
所以我们设计嵌入式操作系统，面向嵌入式，具有实用价值。
两者核心是差不多的，不过用户级操作系统要在操作系统内核上还要加入用户层，还要实现很多API和底层的硬件通信。
功能设计如下：
1. 抢占式调度：63个优先级，可以修改
2. 时间片轮转：同优先级可以固定时间切换
3. 延迟调度：支持延迟函数
4. 阻塞与唤醒
5. 互斥量：解决资源抢占问题
6. 可变形队列：线性队列和环形队列可以转换

操作系统的名字就叫做FOS吧。
FOS：Fast OS/Felix OS
```text
$$$$$$$$\  $$$$$$\   $$$$$$\  
$$  _____|$$  __$$\ $$  __$$\ 
$$ |      $$ /  $$ |$$ /  \__|
$$$$$\    $$ |  $$ |\$$$$$$\  
$$  __|   $$ |  $$ | \____$$\ 
$$ |      $$ |  $$ |$$\   $$ |
$$ |       $$$$$$  |\$$$$$$  |
\__|       \______/  \______/ 
```

在设计阶段不应该过于详细，因为遇到的问题总是比预想的多，在后文实现阶段就会体现出来。

往往是设计一个大的方向，用什么数据结构，整体的划分。
然后具体的冲突会在实现过程中遇到，并在实现过程中解决。
如果发现这过程中解决起来很麻烦，不够优雅，则说明最初的设计有些问题。此时此刻有两种选择，第一种就是做下去，第二种就是根据遇到的问题，重新设计架构，也就是所谓的重构。

我们的设计是
1. 就绪队列：每一个优先级一个环形队列
2. 休眠队列：每次Tick会进行减少计数
3. 挂起队列：这里的任务不会被调度到

具体的实现细节将会在后面的文章中。