# USB2.0物理层电信号

## USB2.0驱动器特性
这里的驱动器，指的是电压，电流，导线类型等，用来驱动USB设备的都算。
这里先省略

## USB2.0设备连接状态的检测
USB设备支持即插即用，所以对于USB主机端，一个重要的特性就是USB设备的动态连接检测。
USB主机端支持设备的连接状态的检测，是需要USB设备的配合的。
USB主机端与USB设备端相互配合，实现了USB设备的连接状态检测。
![usb_speed2](./pages_hardware/usb/res/usb_speed2.png)
USB主机端的D+和D-均有一个15K的下拉电阻，而设备端根据USB设备分为两大类:USB低速和USB全速高速，分别在其设备的D-或D+上拉一个1.5K的电阻。
主机端D+和D-均有一个15K的下拉电阻。
低速设备端D-上拉一个1.5K的电阻
高速设备端D+上拉一个1.5K的电阻

**一个USB设备连接到主机后，大概分为以下几个阶段：**
默认态，USB主机端VBus为高电平。
USB设备连接到USB主机。
USB设备端的VBus从低电平变为高电压(>=4.01V)
USB设备端VBus检测到高电平
USB设备端低速挂接D-上的1.5K上拉电阻，全速或高速设备接接D+上的1.5K上拉电阻。
USB主机端检测到D+/或D-端的电压变高（2.0V以上）
USB主机端根据D+/D-线缆上的电压变化识别USB2.0低速设备或全速设备（高速设备）连接上来
USB主机对检测到的设备发送复位信号，进行设备复位。

## USB2.0设备断开状态的检测
相对于USB设备的连接检测，USB设备断开的检测也很重要，也更加的隐晦。USB设备断开的检测不仅包含USB主机检测到其与设备的断开，也包含USB设备检测到其与主机的连接断开。
1. 对于USB主机来说，如果不能正确的识别设备的断开，从而无法回收已经断开的设备使用的资源，将会导致资源的浪费，这种资源的浪费不仅表现在系统上如USB设备的地址，系统内存等，也表现在USB总线带宽上。
2. 对于USB设备端来说，如果USB设备无法检测到其与主机端已经断开，同样也会引发一些如再次与主机端连接设备不能正确工作的问题。
> 由于USB主机如USB控制器，USB根集线器和USB设备的驱动程序在主机端运行，并且USB主机端是经过千锤百炼的，所以对于USB设备断开引起的异常，大部分的问题都是由USB设备端引起的，并且大部分发生在自供电的USB设备。因为自供电没能很好达到一些USB的电气规范。

USB规范对USB总线VBus上的电压的有规定，所以对于支持VBUS检测的USB设备，可以通过检测VBUS上的电压低于VBSVLD即4.01V时即可认为USB设备与主机已经断开。
对于不支持VBus上检测的USB设备，是通过D+/D-上的电压变化来检测的。
**无论是否支持VBUS检测的USB设备，当检测到设备已经与主机断开后，都需要D+或D-上的上拉电阻，来确保下次连接检测的初始化状态是正确的。**
> 在实际的硬件电路中，VBUS设备端会有一个旁路电容（一般较大），过快的快速插拔导致设备端的VBUS电压因旁路电容的存在导致无法降低到4.01V以下，从而使主机检测不到断开，以保证之前的连接状态。
USB2.0规定，当主机端的D+或D-的电压小于0.8V时，并且持续TDDIS（最小值为2us)的时间长度时，USB主机端就可以认定设备已经断开。对于USB低速或全设备，可以通过此种方式进行设备断开的检测。
对于工作在高速模式下的USB设备，其D+/D-上的电平和低全速的设备不一样，所以检测方式不一样。USB2.0协议规定，对于连接到高速设备的高速主机，D+和D-上的差分信号电平大于625mV时，就可认定USB设备已经断开。

## USB协议制定的思想
1. 通过差分信号，来产生更多种类型的信号组合。
2. 设计了自适应速度的方式：进行对SYNC（同步字段）的信号进行采样，以知道USB设备的传输速率。
3. 设计了多种速度协议，目的是为了适应不同用途。
4. 从低维到高维：先把最底层的`电平信号`进行组合，形成了一些**特定含义**的`标识信号`，再用`标识信号`制定复杂的数据字段，最终形成USB协议。

## 电平信号
根据上面的USB协议制定思想，我们来看USB协议是如何把`电平信号`定义成`标识信号`的。
### 低速/全速设备
$V_{IL}=MinMax\{\infty,0.8V\}$的I是Input，L是Low
$V_{IH}=MinMax\{2.0V,\infty\}$的I是Input，H是High
$V_{IHZ}=MinMax\{2.7V,3.6V\}$的I是Input，H是High，介于2.7-3.6V
$V_{OL}=MinMax\{0.0V,0.3V\}$的O是Output，L是Low
$V_{OH}=MinMax\{2.8V,3.6V\}$的O是Output，H是High
1个bit时间就是发送数据发一个位的时间，由实际传输速度决定。

1. 差分1：(D+) - (D-) \> 200mV
2. 差分0：(D-) - (D+) \> 200mV
3. 信号结束0（Signal End0 SE0）：D+和D- \< $V_{IL}$(即都是低电平)
4. 信号结束1（Signal End1 SE1）：D+和D- \> $V_{IL}$(即都是高电平)
5. 数据J状态：
   1. 低速：差分1
   2. 全速：差分0
6. 数据K状态：
   1. 低速：差分0
   2. 全速：差分1
7. 空闲状态（Idle）：
   1. 低速：D+ \< $V_{IL}$ 且 D- \> $V_{IHZ}$(即，D+为低，D-为高)
   2. 全速：D+ \> $V_{IL}$ 且 D- \< $V_{IHZ}$(即，D+为高，D-为低)
8. 恢复状态（Resume）：数据K状态
9. 包开始（SOP）：从Idle状态到K状态
10. 包结束（EOP）：保持SE0大约2个bits时间，再跟一个J状态，持续1个bit时间。（其实是把**包结束的信号**也当作数据来读取了，然后再判断）
11. 断开连接：SE0 保持 2.5us以上
12. 连接：Idle状态保持2ms以上
13. 复位：D+和D- \< $V_{OL}$ 保持10ms以上
官方手册的原始定义如下：
![usb_state_level1](./pages_hardware/usb/res/usb_state_level1.png)

### 全速/高速设备
高速设备是全速设备在连接后切换到高速通信模式的。

USB如何实现高速通信呢？实际上电压不是突变的，电压的变化是需要时间的。
当把0.8V作为低电平，2.6V作为高电平，那么变化的幅度就很大，所以电平转换所需要的时间就更多。
不过这样也有好处，就是精度高，0和1之间的距离很远，不容易出现错误。
USB高速就是把高电平和低电平的差距缩小，都是毫伏级别，那么速度自然就快了。
这样的思想在设计储存器时经常用到，如固态硬盘就有类似设计。

高速电平支持使用直流和交流两种表达，这里只列直流。
$V_{HSOI}=MinMax\{-10mV,10mV\}$: HS指HighSpeed，O指Output，I指Idle，高速模式空闲电平
$V_{HSOH}=MinMax\{360mV,440mV\}$: HS指HighSpeed，O指Output，H指High，高速模式高电平
$V_{HSOL}=MinMax\{-10mV,10mV\}$: HS指HighSpeed，O指Output，L指Low，高速模式低电平
$V_{CHIRPJ}=MinMax\{700mV,1100mV\}$: CHIRP指Chirp，J指J状态，高速模式Chirp J状态电平
$V_{CHIRPK}=MinMax\{-900mV,-500mV\}$: CHIRP指Chirp，K指K状态，高速模式Chirp K状态电平

1. 差分1：$V_{HSOH} (min) \le D+ \le V_{HSOH} (max)$ 且 $V_{HSOL} (min) \le D- \le V_{HSOL} (max)$
2. 差分0：$V_{HSOH} (min) \le D- \le V_{HSOH} (max)$ 且 $V_{HSOL} (min) \le D+ \le V_{HSOL} (max)$
3. 高速J状态：差分1
4. 高速K状态：差分0
5. 调频J状态（Chirp J）：$V_{CHIRPJ} (min) \le (D+ - D-) \le V_{CHIRPJ} (max)$
6. 调频K状态（Chirp K）：$V_{CHIRPK} (min) \le (D+ - D-) \le V_{CHIRPK} (max)$
7. 空闲状态（Idle）：$V_{HSOI} min ≤ (D+, D-) ≤ V_{HSOI} max$ 就是D+和D-都接地。
8. 包开始（SOP）：从Idle状态，到高速J状态或者高速K状态都可
9. 包结束（EOP）：从高速J状态或者高速K状态，到Idle状态

### 数据信号（Data Signaling）
### 低速/全速模式
SOP标识了一个包的开始，即从Idle状态到K状态，且这一次跳变的K状态就是SYNC同步字段的第一个bit。
EOP标识了一个包的结束，EOP的定义在上文已讲。
SYNC字段：(NRZI 序列 KJKJKJKJ KJKJKJKJ KJKJKJKJ KJKJKJKK) 32bits
下面这幅图可以很好解释。
![usb_data_signaling1](./pages_hardware/usb/res/usb_data_signaling1.png)
### 高速模式
高速模式的Idle状态，就是D+和D-都接地。
SOP标识了一个包的开始，即从Idle状态到K状态，且这一次跳变的K状态就是SYNC同步字段的第一个bit。
虽然上文写的是到K或者J状态都行，但是不知道为什么官方文档这里又**只有K状态**。

## 数据编码解码
USB采用了NRZI编码方式：
低电平(0)：意味着经过NRZI编码后会进行电平翻转
高电平(1)：意味着经过NRZI编码后保持上一次的电平
如图所示
![](./pages_hardware/usb/res/nrzi2.png)
NRZI的高电平表示J状态，NRZI的低电平表示K状态

## 位填充机制(Bit Stuffing)
为了确保有足够的信号来进行NRZI转换，USB选择在NRZI编码之前，对原始的高低电平数据，进行位填充。
填充规则：每遇到6个连续的1之后会加一个0，进行强制NRZI编码后电平反转。
> 为什么要位填充呢？
> 因为一旦电平长时间保持不变时，我们无法知道,到底是发送的是100个逻辑1，还是1000个逻辑1，即使传输的是100个逻辑1，但接收方与发送方的频率相差了100分之1，那么也还是存在可能把数据采集成为99或者101。而USB中采用了Bit-Stuffing位填充处理，即在连续发送6个1后面会插入1个0，强制使发送信号进行翻转，从而让接收方调整频率，同步接收。而接收方在接收时只要接收到连续的6个1后，直接将后面的0删除即可恢复数据的原貌。（因为每一个0前面一定是6个1）

位填充机制和SYNC是一起启用的，所以当SYNC以1结尾时，SYNC也会被当作一个序列。
位填充总是强制开启的，除了高速模式下的EOP模式。

**所以，接收器必须解码NRZI数据，识别填充位，并丢弃它们。**

## SYNC字段
### 低速和全速模式
SYNC字段的定义：3个KJ对，再跟2个K，一共8个符号。
SYNC字段对于每一个低速和全速模式的包都会有。
SYNC字段的最后两个是用来作为SYNC字段的结尾标识用的，同样也是PID（Package Identifier）字段的开始。
### 高速模式
SYNC字段的定义：15个KJ对，再跟2个K，一共32个符号。
对于Hubs（集线器）还有特殊的定义，对于USB设备来说不重要，略。
SYNC字段的最后两个是用来作为SYNC字段的结尾标识用的，同样也是PID（Package Identifier）字段的开始。

## Frame时间间隔
USB定义了：一个Frame的时间($T_{FRAME}$)是1ms +-500ns，一个MicroFrame的时间是125us,+-62.5us。
(micro)frame的测量方法：从EOF(End of Frame)的任意一个点，到下一个frame的EOF的同一个点。