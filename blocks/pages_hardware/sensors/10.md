# OV2640
OV2640是OmniVision公司生产的一颗1/4寸的CMOS UXGA（1632*1232）图像传感器。
内置25Mhz晶体振荡器，外围电路简单，使用方便，200W像素。
1. 采用SCCB接口（OV公司的自定义总线）类似IIC
2. 输出格式：RawRGB，RGB565/555，GRB422，YUV，YCbCr，JPEG
3. 输出位宽：8bits
4. 输出帧率：UXGA(1600*1200) 15帧/秒
5. 输出帧率：SVGA(800*600) 30帧/秒
6. 输出帧率：CIF(352*288) 60帧/秒
7. 光圈：F2.0
8. 视野：78°
9. 焦距：3.6mm
10. 功耗：40mA
11. 电源电压：3.3V，
12. IO电压：2.8V，兼容3.3V

## SCCB BUS
SCCB BUS就像是IIC的阉割版，因为IIC是有专利的，所以OV就在IIC的基础上阉割了连续传输的功能，这样就不用付专利费了。
OV摄像头作为从机，MCU作为主机。
SCCB BUS有三条线：
1. SCCB_E：1表示总线空闲，0表示总线挂起，当正在传输的时候，必须把SCCB_E拉低。
2. SIO_C：表示传输的时钟，当总线空闲的时候，必须把SIO_C拉高，开始传输时拉低，然后就交替起到时钟的作用。
3. SIO_D：数据通道，数据可以从主机发起，也可以从从机发起，是一个双向口。当BUS是空闲的时候应该保持浮空(输入态)（必要）
4. PWDN：Power Down

部分OV摄像头没有SCCB_E接口。当没有SCCB_E的时候，只能实现一主一从的通信方式。
且主机的SIO_D需要是三态门，也叫是可以输出可以输入。

开始标识：
两线：当SIO_C为高的时候，SIO_D是下降沿
三线：两线基础上，SCCB_E比SIO_D慢15ns拉低

结束标识：
两线：当SIO_C为高的时候，SIO_D是上升沿
三线：在两线基础上，SCCB_E可以和SIO_D同时拉高或者慢几ns

SCCB的读写方式和IIC一模一样，都是先发地址，再发数据。
只不过IIC的ACK在SCCB里面没有意义，只不过是为了适配IIC
三段写：发设备地址，发寄存器地址，数据
两段写：发设备地址，发寄存器地址
两段读：发设备地址，数据

两段写之后一定要跟一个两段读，目的是为了指示读操作的寄存器地址。
这就是SCCB把IIC阉割的地方。IIC是可以实现：读写切换的但是SCCB就只能停下再来，因为少了ACK和NACK的支持，不知道传输结束标识。
**简而言之，可以直接用IIC协议来当作SCCB协议，只不过在读写的时候要遵守上面的方式，不能连续。**

## 色彩空间
### RGB
RGB是计算机软件上常用的格式，R(Red)，G(Green)，B(Blue)，分别代表了三个颜色的分量，使用的三原色的色彩叠加的原理。
RGB是一种面向硬件的色彩空间。

### HSV
H：Hue，色相，范围[0-360]
S：Saturation，饱和度，范围[0-100]
V：Value，明度，范围[0-100]
HSV的最顶部是最明亮的，V可以理解为色彩反射出的光的强度。
HSV是一种面向人类的色彩空间。

### HSL
H：Hue，色相，范围[0-360]
S：Saturation，饱和度，范围[0-100]
L：Lightness，亮度，范围[0-100]
HSL在顶部是全白的，L可以理解为在纯色里面混入白色的量。
HSV是一种面向人类的色彩空间。
但是这个L有一些些反直觉。

### CMYK
CMYK：C(Cyan)，M(Magenta)，Y(Yellow)，K(blacK)
之所以最后是K，是为了避免和Blue混淆
这种色彩空间用于印刷
CMYK是一种减色模式，RGB是加色模式，这就是为什么显示屏是RGB，而印刷是CMYK。
CMY理论上也是可以合成黑色，但是纯度不够黑，所以就额外用纯色的黑色来补充。

## YUV编码方式
准确的说YUV是一种色彩的编码方式，是一种面向硬件传输的色彩格式。
YUV：Y(明亮度)，U(色度)，V(饱和度)

YCbCr其实是 YUV 经过缩放和偏移的翻版。其中Y与YUV中的Y含义一致,Cb,Cr同样都指色彩，只是在表示方法上不同而已。
YCbCr其中Y是指亮度分量，Cb指蓝色色度分量，而Cr指红色色度分量。

**并不是所有像素都需要包含YUV，可以实现共享像素，如下规则**
YUV：表示三个分量，每个分量占8bits
YUV444：每传输4个Y，会传输4个U，4个V
YUV422：每传输4个Y，会传输2个U，2个V
YUV420：每传输8个Y，会传输2个U，2个V

YUV420也可以理解为：
第一次YUV420：每传输4个Y，会传输2个U，0个V
第二次YUV402：每传输4个Y，会传输0个U，2个V
第三次又变成YUV420

下面举一些例子
```plaintext
YUV444:
下面的四个像素为: [Y0 U0 V0] [Y1 U1 V1] [Y2 U2 V2] [Y3 U3 V3]
存放的码流为: Y0 U0 V0 Y1 U1 V1 Y2 U2 V2 Y3 U3 V3
产生的像素：[Y0 U0 V0] [Y1 U1 V1] [Y2 U2 V2] [Y3 U3 V3]

YUV422:
下面的四个像素为：[Y0 U0 V0] [Y1 U1 V1] [Y2 U2 V2] [Y3 U3 V3]
存放的码流为：Y0 U0 Y1 V1 Y2 U2 Y3 V3
映射出像素点为：[Y0 U0 V1] [Y1 U0 V1] [Y2 U2 V3] [Y3 U2 V3]

YUV420:
下面八个像素为: [Y0 U0 V0] [Y1 U1 V1] [Y2 U2 V2] [Y3 U3 V3]
               [Y4 U4 V4] [Y5 U5 V5] [Y6 U6 V6] [Y7 U7 V7]
存放的码流为：Y0 U0 Y1 Y2 U2 Y3 Y4 V4 Y5 Y6 V6 Y7
映射出的像素点为：[Y0 U0 V4] [Y1 U0 V4] [Y2 U2 V6] [Y3 U2 V6]
                [Y4 U0 V4] [Y5 U0 V4] [Y6 U2 V6] [Y7 U2 V6]

具体的码流顺序，要看传感器的输出
```
对上面例子的总结是
YUV 4:4:4采样，每一个Y对应一组UV分量。
YUV 4:2:2采样，每两个Y共用一组UV分量。 
YUV 4:2:0采样，每四个Y共用一组UV分量。

YUV格式有两大类：planar和packed。
对于planar的YUV格式，先连续存储所有像素点的Y，紧接着存储所有像素点的U，随后是所有像素点的V。
对于packed的YUV格式，每个像素点的Y,U,V是连续交错存储的。（就是上面例子所采用的格式）
有时候也表示成：
YUYV，YVYU，VYUY，直接表示成YUV的传输顺序

## 色彩模式选择
OV2640支持：YcbCr422，YcbCr420，RGB565，RawRGB
如果要转换成RGB888(RGB24)需要自己来解算。
有两种方案：一种是浮点运算，一种是整数运算，根据自己MCU的硬件情况进行选择。
$R=Y+1.371(Cr-128)$
$G=Y-0.698(Cr-128)-0.336(Cb-128)$
$B=Y+1.732(Cb-128)$

$R=Y+(351*(Cr–128))>>8$
$G=Y–(179*(Cr–128)+86*(Cb–128))>>8$
$B=Y+(443*(Cb–128))>>8$

## 输出大小选择
1. 输出帧率：UXGA(1600*1200) 15帧/秒
2. 输出帧率：SVGA(800*600) 30帧/秒
3. 输出帧率：CIF(352*288) 60帧/秒

注意摄像头Preview和Capture的区别：
Preview：用较低分辨率来预览，为了提高速度，降低功耗。
Capture：一般是单帧，用较大的分辨率进行捕获
